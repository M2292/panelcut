<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PanelSnip - Snip Comic Panels</title>
    <link rel="icon" href="/static/favicon.svg" type="image/svg+xml">
    <link rel="icon" href="/static/favicon.png" type="image/png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f0f0f;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #252525;
            --accent: #ff6b6b;
            --accent-hover: #ff8787;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --border: #333333;
            --success: #4caf50;
            --warning: #ff9800;
            --info: #2196f3;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
        }

        /* Compact Header */
        header {
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 20px;
            flex-shrink: 0;
        }

        .logo {
            font-size: 1.4rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent) 0%, #ffa07a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats-counter {
            display: flex;
            gap: 15px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            justify-self: end;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-value {
            color: var(--accent);
            font-weight: 600;
        }

        .new-page-btn {
            padding: 10px 20px;
            font-size: 0.95rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent) 0%, #ff8a65 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
            white-space: nowrap;
            justify-self: center;
        }

        .new-page-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
        }

        .new-page-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .new-page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--bg-tertiary);
            box-shadow: none;
        }

        /* Main Layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0;
        }

        /* Canvas Area (Left) */
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;  /* Hide overflow for transform-based panning */
            min-width: 0;
        }

        .canvas-area.panning {
            cursor: grabbing !important;
        }

        /* Drop Zone (shown when no image) */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--bg-secondary);
            max-width: 500px;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: var(--accent);
            background: rgba(255, 107, 107, 0.05);
        }

        .drop-zone.hidden {
            display: none;
        }

        .drop-zone-icon {
            font-size: 4rem;
            margin-bottom: 15px;
            opacity: 0.7;
        }

        .drop-zone-text {
            font-size: 1.1rem;
            color: var(--text-secondary);
        }

        .file-input {
            display: none;
        }

        /* Canvas Wrapper */
        .canvas-wrapper {
            position: relative;
            display: none;
            background: #000;
            border-radius: 8px;
            overflow: visible;
            transform-origin: center center;
            will-change: transform;
        }

        .canvas-wrapper.active {
            display: block;
        }

        #editorCanvas {
            display: block;
            cursor: crosshair;
        }

        .canvas-wrapper.eraser-mode #editorCanvas {
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="%23ff6b6b" fill-opacity="0.3" stroke="%23ff0000" stroke-width="2"/><line x1="7" y1="7" x2="17" y2="17" stroke="%23ff0000" stroke-width="2"/><line x1="17" y1="7" x2="7" y2="17" stroke="%23ff0000" stroke-width="2"/></svg>') 12 12, auto;
        }

        /* Zoom indicator */
        .zoom-indicator {
            position: fixed;
            top: 80px;
            right: 320px;  /* Sidebar width (280px) + padding */
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            pointer-events: none;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(4px);
        }

        .zoom-indicator.hidden {
            opacity: 0;
        }

        /* Panels Sidebar (Right) */
        .panels-sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .panel-count-badge {
            background: var(--accent);
            color: white;
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .sidebar-actions {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 8px;
        }

        .sidebar-actions.hidden {
            display: none;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .sidebar-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            text-align: center;
            padding: 20px;
        }

        .sidebar-empty-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* Panel Thumbnails */
        .panels-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel-thumb {
            position: relative;
            background: var(--bg-tertiary);
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .panel-thumb:hover {
            border-color: var(--accent);
        }

        .panel-thumb.selected {
            border-color: var(--success);
        }

        .panel-thumb.unselected {
            opacity: 0.5;
        }

        .panel-thumb img {
            width: 100%;
            height: auto;
            display: block;
        }

        .panel-thumb-number {
            position: absolute;
            top: 6px;
            left: 6px;
            background: var(--accent);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.75rem;
        }

        .panel-thumb-checkbox {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--success);
        }

        /* Bottom Toolbar */
        .bottom-toolbar {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-group.hidden {
            display: none;
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: var(--border);
            margin: 0 5px;
        }

        .toolbar-spacer {
            flex: 1;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--accent-hover);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--border);
        }

        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #45a049;
        }

        .btn-success:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .btn-info {
            background: var(--info);
            color: white;
        }

        .btn.active {
            box-shadow: 0 0 0 2px var(--accent);
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        /* Toggle */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .toggle {
            position: relative;
            width: 40px;
            height: 22px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            inset: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 22px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background: var(--text-secondary);
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle input:checked + .toggle-slider {
            background: var(--accent);
            border-color: var(--accent);
        }

        .toggle input:checked + .toggle-slider:before {
            transform: translateX(18px);
            background: white;
        }

        /* Select dropdown */
        .select-small {
            padding: 6px 10px;
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            cursor: pointer;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast notifications */
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Responsive */
        @media (max-width: 900px) {
            .panels-sidebar {
                width: 200px;
            }
        }

        @media (max-width: 700px) {
            .main-container {
                flex-direction: column;
            }

            .panels-sidebar {
                width: 100%;
                height: 200px;
                border-left: none;
                border-top: 1px solid var(--border);
            }

            .sidebar-content {
                display: flex;
                overflow-x: auto;
                overflow-y: hidden;
            }

            .panels-list {
                flex-direction: row;
            }

            .panel-thumb {
                min-width: 120px;
            }

            .bottom-toolbar {
                padding: 10px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
        }

        /* Page Navigator (Bulk Mode) */
        .page-navigator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 10px 15px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }

        .page-indicator {
            font-weight: 600;
            min-width: 100px;
            text-align: center;
            color: var(--text-primary);
        }

        /* Page Thumbnails Strip */
        .page-thumbs-strip {
            display: flex;
            gap: 8px;
            padding: 10px;
            overflow-x: auto;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }

        .page-thumb {
            position: relative;
            width: 50px;
            height: 70px;
            flex-shrink: 0;
            border: 2px solid transparent;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.2s;
        }

        .page-thumb:hover {
            opacity: 0.9;
        }

        .page-thumb.active {
            border-color: var(--accent);
            opacity: 1;
        }

        .page-thumb.detected {
            border-color: var(--success);
        }

        .page-thumb.detected.active {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--success);
        }

        .page-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .page-thumb-number {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 9px;
            padding: 1px 4px;
            border-radius: 2px;
        }

        .page-thumb-status {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning);
        }

        .page-thumb.detected .page-thumb-status {
            background: var(--success);
        }

        .page-thumb.extracted .page-thumb-status {
            background: var(--info);
        }

        .page-thumb-delete {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            line-height: 18px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .page-thumb:hover .page-thumb-delete {
            opacity: 1;
        }

        .page-thumb-delete:hover {
            background: rgba(220, 53, 69, 1);
            transform: scale(1.1);
        }

        /* Bulk mode toolbar additions */
        .bulk-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .bulk-progress {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-left: 10px;
        }

        /* Panel drag-and-drop reordering */
        .panel-thumb.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .panel-thumb.drag-over {
            border-color: var(--accent) !important;
            box-shadow: 0 0 0 2px var(--accent);
        }

        .panel-thumb .drag-handle {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: rgba(0,0,0,0.6);
            border-radius: 3px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 2;
        }

        .panel-thumb:hover .drag-handle {
            opacity: 1;
        }

        .panel-thumb .drag-handle:active {
            cursor: grabbing;
        }

        .reorder-hint {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
            padding: 4px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }

        /* View Toggle */
        .sidebar-header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .view-toggle {
            display: flex;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .view-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 4px 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .view-btn:hover {
            color: var(--text-primary);
            background: var(--border);
        }

        .view-btn.active {
            background: var(--accent);
            color: white;
        }

        /* Grid View Mode */
        .panels-list.grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 6px;
        }

        .panels-list.grid-view .reorder-hint {
            grid-column: 1 / -1;
        }

        .panels-list.grid-view .panel-thumb {
            aspect-ratio: 3/4;
        }

        .panels-list.grid-view .panel-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .panels-list.grid-view .panel-thumb-number {
            font-size: 9px;
            padding: 1px 3px;
        }

        .panels-list.grid-view .panel-thumb-checkbox {
            width: 12px;
            height: 12px;
        }

        .panels-list.grid-view .drag-handle {
            width: 14px;
            height: 14px;
            font-size: 9px;
        }
    </style>
</head>
<body>
    <!-- Compact Header -->
    <header>
        <div class="logo">PanelSnip</div>
        <button class="new-page-btn" id="newPageBtn" disabled>+ New Page</button>
        <div class="stats-counter" id="statsCounter">
            <div class="stat-item">
                <span>Downloads:</span>
                <span class="stat-value" id="totalDownloads">-</span>
            </div>
            <div class="stat-item">
                <span>Panels:</span>
                <span class="stat-value" id="totalPanels">-</span>
            </div>
        </div>
    </header>

    <!-- Main Layout -->
    <div class="main-container">
        <!-- Canvas Area -->
        <div class="canvas-area" id="canvasArea">
            <!-- Drop Zone (shown when no image) -->
            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-icon">&#128444;</div>
                <p class="drop-zone-text">Drop manga page(s) here<br>or click to browse<br><small style="opacity: 0.7;">Select multiple for bulk mode</small></p>
                <input type="file" class="file-input" id="fileInput" accept="image/*" multiple>
            </div>

            <!-- Canvas (shown when image loaded) -->
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="editorCanvas"></canvas>
            </div>

            <!-- Zoom indicator (fixed position overlay) -->
            <div class="zoom-indicator hidden" id="zoomIndicator">100%</div>
        </div>

        <!-- Panels Sidebar -->
        <div class="panels-sidebar">
            <!-- Page Navigator (Bulk Mode) -->
            <div class="page-navigator" id="pageNavigator" style="display: none;">
                <button class="btn btn-small btn-secondary" id="prevPageBtn" disabled>&lt;</button>
                <span class="page-indicator" id="pageIndicator">Page 1 / 1</span>
                <button class="btn btn-small btn-secondary" id="nextPageBtn" disabled>&gt;</button>
            </div>
            <!-- Page Thumbnails Strip (Bulk Mode) -->
            <div class="page-thumbs-strip" id="pageThumbsStrip" style="display: none;">
                <!-- Populated dynamically -->
            </div>
            <div class="sidebar-header">
                <span class="sidebar-title">Panels</span>
                <div class="sidebar-header-right">
                    <div class="view-toggle" id="viewToggle">
                        <button class="view-btn active" id="listViewBtn" title="List view">&#9776;</button>
                        <button class="view-btn" id="gridViewBtn" title="Grid view">&#9638;</button>
                    </div>
                    <span class="panel-count-badge" id="panelCountBadge">0</span>
                </div>
            </div>
            <div class="sidebar-actions hidden" id="sidebarActions">
                <button class="btn btn-small btn-secondary" id="selectAllBtn">All</button>
                <button class="btn btn-small btn-secondary" id="deselectAllBtn">None</button>
            </div>
            <div class="sidebar-content" id="sidebarContent">
                <div class="sidebar-empty" id="sidebarEmpty">
                    <div class="sidebar-empty-icon">&#128247;</div>
                    <p>Upload an image and click<br><strong>Auto-Detect</strong> to find panels</p>
                </div>
                <div class="panels-list" id="panelsList"></div>
            </div>
        </div>
    </div>

    <!-- Bottom Toolbar -->
    <div class="bottom-toolbar">
        <!-- Primary Actions -->
        <div class="toolbar-group" id="primaryActions">
            <button class="btn btn-info" id="autoDetectBtn" disabled>Auto-Detect</button>
            <button class="btn btn-success" id="extractBtn" disabled>Extract Panels</button>
        </div>

        <!-- Bulk Actions (shown in bulk mode) -->
        <div class="toolbar-group hidden" id="bulkActions">
            <button class="btn btn-info" id="detectAllBtn">Detect All</button>
            <button class="btn btn-success" id="extractAllBtn" disabled>Extract All</button>
            <span class="bulk-progress" id="bulkProgress"></span>
        </div>

        <div class="toolbar-divider"></div>

        <!-- Edit Tools (shown after detection) -->
        <div class="toolbar-group hidden" id="editTools">
            <button class="btn btn-secondary active" id="panBtn" title="Pan/Move view (H)">âœ‹ Hand</button>
            <button class="btn btn-secondary" id="rectBtn" title="Draw rectangle (R)">Rect</button>
            <button class="btn btn-secondary" id="eraserBtn" title="Delete panel (D)">Delete</button>
            <button class="btn btn-secondary" id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
            <button class="btn btn-secondary" id="redoBtn" title="Redo (Ctrl+Y)">Redo</button>
            <button class="btn btn-secondary" id="clearBtn" title="Clear all panels">Clear</button>
        </div>

        <div class="toolbar-divider hidden" id="editDivider"></div>

        <!-- Options -->
        <div class="toolbar-group" id="optionsGroup">
            <div class="toggle-container">
                <span>LTR</span>
                <label class="toggle">
                    <input type="checkbox" id="rtlToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span>RTL</span>
            </div>
            <select class="select-small" id="modelSelect">
                <option value="hybrid">Hybrid</option>
                <option value="yolo">YOLO</option>
                <option value="seg_v2">Seg v2</option>
            </select>
        </div>

        <div class="toolbar-spacer"></div>

        <!-- Export (shown after extraction) -->
        <div class="toolbar-group hidden" id="exportTools">
            <button class="btn btn-success" id="downloadBtn" disabled>Download ZIP</button>
            <button class="btn btn-info" id="downloadPsdBtn" disabled>Download PSD</button>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading">
        <div class="loading-content">
            <div class="spinner"></div>
            <p>Processing...</p>
        </div>
    </div>

    <script>
        // =====================================================================
        // STATE
        // =====================================================================
        let currentImage = null;
        let currentImageData = null;
        let currentPanels = [];
        let selectedPanels = new Set();
        let rectangles = [];
        let lastExtractedRectangles = null;
        let currentRect = null;
        let selectedRect = null;
        let draggedCorner = null;
        let hoveredCorner = null;
        let rectStartPos = null;
        let dragStartPos = null;  // For dragging entire rectangles
        let isDraggingRect = false;
        let cornerDragStartPos = null;  // For Ctrl+drag straight line constraint
        let history = [];
        let redoHistory = [];
        let currentTool = 'pan';  // Default to pan tool
        let isDrawing = false;
        let scale = 1;
        let zoomLevel = 1;  // User-controlled zoom
        let panX = 0;  // Pan offset X
        let panY = 0;  // Pan offset Y
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let scrollStartX = 0;
        let scrollStartY = 0;
        let spaceKeyDown = false;
        let mousePos = null;
        let lastYoloResult = null;
        let confirmedRects = new Set();  // Track which rectangles are "locked" for overlap resolution

        // Bulk mode state
        let bulkMode = false;
        let bulkPages = [];  // Array of page objects
        let currentPageIndex = 0;
        // Page object structure:
        // { file, fileName, imageData, image, rectangles, panels, detected, extracted }

        const CORNER_SIZE = 10;

        // Mask canvas for editing
        let maskCanvas = null;
        let maskCtx = null;

        // =====================================================================
        // DOM ELEMENTS
        // =====================================================================
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const canvas = document.getElementById('editorCanvas');
        const ctx = canvas.getContext('2d');
        const canvasArea = document.getElementById('canvasArea');
        const zoomIndicator = document.getElementById('zoomIndicator');

        // Sidebar
        const sidebarContent = document.getElementById('sidebarContent');
        const sidebarEmpty = document.getElementById('sidebarEmpty');
        const panelsList = document.getElementById('panelsList');
        const panelCountBadge = document.getElementById('panelCountBadge');
        const sidebarActions = document.getElementById('sidebarActions');
        const listViewBtn = document.getElementById('listViewBtn');
        const gridViewBtn = document.getElementById('gridViewBtn');

        // View mode state
        let currentViewMode = 'list'; // 'list' or 'grid'

        // Toolbar
        const autoDetectBtn = document.getElementById('autoDetectBtn');
        const extractBtn = document.getElementById('extractBtn');
        const editTools = document.getElementById('editTools');
        const editDivider = document.getElementById('editDivider');
        const exportTools = document.getElementById('exportTools');
        const panBtn = document.getElementById('panBtn');
        const rectBtn = document.getElementById('rectBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const clearBtn = document.getElementById('clearBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadPsdBtn = document.getElementById('downloadPsdBtn');
        const rtlToggle = document.getElementById('rtlToggle');
        const modelSelect = document.getElementById('modelSelect');

        // Hide model selector in production (only show locally)
        const isProduction = !window.location.hostname.includes('localhost') && !window.location.hostname.includes('127.0.0.1');

        // Fetch and display download stats
        async function fetchStats() {
            try {
                const response = await fetch('/api/stats');
                if (response.ok) {
                    const stats = await response.json();
                    document.getElementById('totalDownloads').textContent = stats.total_downloads.toLocaleString();
                    document.getElementById('totalPanels').textContent = stats.total_panels.toLocaleString();
                }
            } catch (e) {
                // Silently fail - stats are not critical
            }
        }

        // Fetch stats on page load
        fetchStats();

        if (isProduction && modelSelect) {
            modelSelect.style.display = 'none';
        }

        const selectAllBtn = document.getElementById('selectAllBtn');
        const deselectAllBtn = document.getElementById('deselectAllBtn');
        const newPageBtn = document.getElementById('newPageBtn');

        // Bulk mode elements
        const pageNavigator = document.getElementById('pageNavigator');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageIndicator = document.getElementById('pageIndicator');
        const pageThumbsStrip = document.getElementById('pageThumbsStrip');
        const bulkActions = document.getElementById('bulkActions');
        const detectAllBtn = document.getElementById('detectAllBtn');
        const extractAllBtn = document.getElementById('extractAllBtn');
        const bulkProgress = document.getElementById('bulkProgress');

        const loading = document.getElementById('loading');

        // =====================================================================
        // FILE UPLOAD
        // =====================================================================
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) handleFiles(e.target.files);
        });

        // Helper functions for async file/image loading
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        async function handleFiles(files) {
            // Filter for image files only
            const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
            if (imageFiles.length === 0) {
                alert('Please select image file(s)');
                return;
            }

            if (imageFiles.length === 1) {
                // Single file - use existing behavior
                handleFile(imageFiles[0]);
                return;
            }

            // Multiple files - enter bulk mode
            loading.classList.add('active');
            updateLoadingText('Loading images...');

            try {
                bulkMode = true;
                bulkPages = [];

                // Sort files by name for consistent ordering
                const sortedFiles = imageFiles.sort((a, b) =>
                    a.name.localeCompare(b.name, undefined, {numeric: true})
                );

                for (let i = 0; i < sortedFiles.length; i++) {
                    updateLoadingText(`Loading image ${i + 1} of ${sortedFiles.length}...`);
                    const file = sortedFiles[i];
                    const imageData = await readFileAsDataURL(file);
                    const image = await loadImage(imageData);

                    bulkPages.push({
                        file: file,
                        fileName: file.name,
                        imageData: imageData,
                        image: image,
                        rectangles: [],
                        panels: [],
                        detected: false,
                        extracted: false
                    });
                }

                currentPageIndex = 0;
                showBulkMode();
                loadPage(0, true);  // Skip save on initial load
            } catch (error) {
                console.error('Error loading images:', error);
                alert('Error loading images: ' + error.message);
                bulkMode = false;
                bulkPages = [];
            } finally {
                loading.classList.remove('active');
            }
        }

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }

            // Reset bulk mode when loading single file
            bulkMode = false;
            bulkPages = [];
            currentPageIndex = 0;
            hideBulkMode();

            const reader = new FileReader();
            reader.onload = (e) => {
                currentImageData = e.target.result;
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    initCanvas();
                    showImageLoaded();
                };
                img.src = currentImageData;
            };
            reader.readAsDataURL(file);
        }

        function showImageLoaded() {
            dropZone.classList.add('hidden');
            canvasWrapper.classList.add('active');
            autoDetectBtn.disabled = false;
            // headerInfo removed = `${currentImage.width} x ${currentImage.height} px`;

            // Reset state
            rectangles = [];
            currentPanels = [];
            selectedPanels.clear();
            history = [];
            redoHistory = [];
            lastYoloResult = null;

            // Update UI
            updateExtractButton();
            hideEditTools();
            hideExportTools();
            showNewPageBtn(); // Show New Page button once image is loaded
            clearPanelsList();
            sidebarEmpty.querySelector('p').innerHTML = 'Click <strong>Auto-Detect</strong><br>to find panels';

            redraw();
        }

        function initCanvas() {
            const container = canvasArea;
            const maxWidth = container.clientWidth - 40;
            const maxHeight = container.clientHeight - 40;

            // Base scale to fit image in container
            scale = Math.min(maxWidth / currentImage.width, maxHeight / currentImage.height, 1);

            // Reset zoom and pan when loading new image
            zoomLevel = 1;
            panX = 0;
            panY = 0;

            updateCanvasSize();
            updateCanvasTransform();

            // Initialize mask canvas at full resolution
            maskCanvas = document.createElement('canvas');
            maskCanvas.width = currentImage.width;
            maskCanvas.height = currentImage.height;
            maskCtx = maskCanvas.getContext('2d');
            maskCtx.fillStyle = '#ffffff';
            maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
        }

        function updateCanvasSize() {
            if (!currentImage) return;
            const totalScale = scale * zoomLevel;
            canvas.width = currentImage.width * totalScale;
            canvas.height = currentImage.height * totalScale;
        }

        function updateCanvasTransform() {
            // Apply pan offset using CSS transform for smooth, unlimited panning
            canvasWrapper.style.transform = `translate(${panX}px, ${panY}px)`;
        }

        function updateZoomIndicator() {
            const zoomPercent = Math.round(zoomLevel * 100);
            zoomIndicator.textContent = `${zoomPercent}%`;
            zoomIndicator.classList.remove('hidden');

            // Hide after 2 seconds
            clearTimeout(window.zoomIndicatorTimeout);
            window.zoomIndicatorTimeout = setTimeout(() => {
                zoomIndicator.classList.add('hidden');
            }, 2000);
        }

        // =====================================================================
        // DRAWING
        // =====================================================================
        function redraw() {
            if (!currentImage) return;

            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            drawRectangles();
        }

        const rectColors = [
            '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF',
            '#00FFFF', '#FF8000', '#8000FF', '#00FF80', '#0080FF',
        ];

        function drawRectangles() {
            rectangles.forEach((rect, index) => {
                drawRectangle(rect, rect === selectedRect, index);
            });

            if (currentRect) {
                drawRectangle(currentRect, true, -1);
            }
        }

        function drawRectangle(rect, isSelected, index) {
            if (!rect || !rect.corners || rect.corners.length < 3) return;

            const corners = rect.corners;
            const isConfirmed = confirmedRects.has(rect);
            const baseColor = index >= 0 ? rectColors[index % rectColors.length] : '#00FF00';
            const strokeColor = isSelected ? '#FFFFFF' : baseColor;
            const totalScale = scale * zoomLevel;

            ctx.strokeStyle = strokeColor;
            // Thicker border for confirmed rects
            ctx.lineWidth = isConfirmed ? 5 * totalScale : 3 * totalScale;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Dashed line for confirmed rects
            if (isConfirmed) {
                ctx.setLineDash([10 * totalScale, 5 * totalScale]);
            } else {
                ctx.setLineDash([]);
            }

            ctx.beginPath();
            ctx.moveTo(corners[0].x * totalScale, corners[0].y * totalScale);
            for (let i = 1; i < corners.length; i++) {
                ctx.lineTo(corners[i].x * totalScale, corners[i].y * totalScale);
            }
            ctx.closePath();
            ctx.stroke();

            ctx.setLineDash([]); // Reset dash

            ctx.fillStyle = baseColor + (isConfirmed ? '20' : '30'); // Less transparent for confirmed
            ctx.fill();

            // Corner handles if selected
            if (isSelected) {
                corners.forEach((corner, i) => {
                    const isHovered = (rect === selectedRect && i === hoveredCorner);
                    const canDelete = corners.length > 3;

                    if (isHovered && canDelete) {
                        ctx.fillStyle = '#ff4444';
                        ctx.strokeStyle = '#cc0000';
                    } else {
                        ctx.fillStyle = '#ffffff';
                        ctx.strokeStyle = baseColor;
                    }
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(corner.x * totalScale, corner.y * totalScale, CORNER_SIZE, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                });
            }

            // Panel number label
            if (index >= 0) {
                const label = (index + 1).toString();
                const centerX = corners.reduce((sum, c) => sum + c.x, 0) / corners.length;
                const centerY = corners.reduce((sum, c) => sum + c.y, 0) / corners.length;

                ctx.font = `bold ${Math.max(16, 24 * totalScale)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const metrics = ctx.measureText(label);
                const padding = 6 * totalScale;
                ctx.fillStyle = baseColor;
                ctx.fillRect(
                    centerX * totalScale - metrics.width / 2 - padding,
                    centerY * totalScale - 12 * totalScale - padding,
                    metrics.width + padding * 2,
                    24 * totalScale + padding * 2
                );

                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(label, centerX * totalScale, centerY * totalScale);
            }
        }

        // =====================================================================
        // CANVAS INTERACTION
        // =====================================================================
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const totalScale = scale * zoomLevel;
            return {
                x: (e.clientX - rect.left) / totalScale,
                y: (e.clientY - rect.top) / totalScale
            };
        }

        function getCornerAtPos(rect, pos) {
            if (!rect || !rect.corners) return -1;
            const totalScale = scale * zoomLevel;
            const threshold = 20 / totalScale;
            let closestDist = Infinity;
            let closestIdx = -1;
            for (let i = 0; i < rect.corners.length; i++) {
                const corner = rect.corners[i];
                const dx = pos.x - corner.x;
                const dy = pos.y - corner.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < threshold && dist < closestDist) {
                    closestDist = dist;
                    closestIdx = i;
                }
            }
            return closestIdx;
        }

        function isInsideRect(rect, pos) {
            if (!rect || !rect.corners || rect.corners.length < 3) return false;
            const corners = rect.corners;
            const n = corners.length;
            let inside = false;
            for (let i = 0, j = n - 1; i < n; j = i++) {
                const xi = corners[i].x, yi = corners[i].y;
                const xj = corners[j].x, yj = corners[j].y;
                if (((yi > pos.y) !== (yj > pos.y)) &&
                    (pos.x < (xj - xi) * (pos.y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function getEdgeAtPos(rect, pos) {
            if (!rect || !rect.corners || rect.corners.length < 3) return { edge: -1, dist: Infinity };
            const corners = rect.corners;
            const n = corners.length;
            let closestEdge = -1;
            let closestDist = Infinity;
            const totalScale = scale * zoomLevel;
            const threshold = 15 / totalScale;

            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                const dist = pointToSegmentDistance(pos, corners[i], corners[j]);
                if (dist < threshold && dist < closestDist) {
                    closestDist = dist;
                    closestEdge = i;
                }
            }
            return { edge: closestEdge, dist: closestDist };
        }

        function pointToSegmentDistance(p, a, b) {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const lenSq = dx * dx + dy * dy;
            if (lenSq === 0) return Math.sqrt((p.x - a.x) ** 2 + (p.y - a.y) ** 2);

            let t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / lenSq;
            t = Math.max(0, Math.min(1, t));

            const nearestX = a.x + t * dx;
            const nearestY = a.y + t * dy;
            return Math.sqrt((p.x - nearestX) ** 2 + (p.y - nearestY) ** 2);
        }

        function addPointToEdge(rect, edgeIdx, pos) {
            if (!rect || edgeIdx < 0 || edgeIdx >= rect.corners.length) return;
            rect.corners.splice(edgeIdx + 1, 0, { x: pos.x, y: pos.y });
        }

        // =====================================================================
        // OVERLAP RESOLUTION
        // =====================================================================

        function lineSegmentsIntersect(p1, p2, p3, p4) {
            // Check if line segment p1-p2 intersects with p3-p4
            const x1 = p1.x, y1 = p1.y;
            const x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y;
            const x4 = p4.x, y4 = p4.y;

            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (Math.abs(denom) < 1e-10) return null; // Parallel or coincident

            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return {
                    x: x1 + ua * (x2 - x1),
                    y: y1 + ua * (y2 - y1)
                };
            }
            return null;
        }

        function polygonContainsPoint(poly, point) {
            // Ray casting algorithm
            const corners = poly.corners;
            const n = corners.length;
            let inside = false;

            for (let i = 0, j = n - 1; i < n; j = i++) {
                const xi = corners[i].x, yi = corners[i].y;
                const xj = corners[j].x, yj = corners[j].y;
                if (((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function polygonsOverlap(rect1, rect2) {
            if (!rect1 || !rect2 || !rect1.corners || !rect2.corners) return false;
            if (rect1.corners.length < 3 || rect2.corners.length < 3) return false;

            // Check if any corner of rect1 is inside rect2
            for (const corner of rect1.corners) {
                if (polygonContainsPoint(rect2, corner)) return true;
            }

            // Check if any corner of rect2 is inside rect1
            for (const corner of rect2.corners) {
                if (polygonContainsPoint(rect1, corner)) return true;
            }

            // Check if any edges intersect
            const n1 = rect1.corners.length;
            const n2 = rect2.corners.length;
            for (let i = 0; i < n1; i++) {
                const p1 = rect1.corners[i];
                const p2 = rect1.corners[(i + 1) % n1];
                for (let j = 0; j < n2; j++) {
                    const p3 = rect2.corners[j];
                    const p4 = rect2.corners[(j + 1) % n2];
                    if (lineSegmentsIntersect(p1, p2, p3, p4)) return true;
                }
            }

            return false;
        }

        function getPolygonIntersectionPoints(bottomRect, topRect) {
            // Find all intersection points between the two polygons
            const intersections = [];
            const n1 = bottomRect.corners.length;
            const n2 = topRect.corners.length;

            // Find edge-edge intersections
            for (let i = 0; i < n1; i++) {
                const p1 = bottomRect.corners[i];
                const p2 = bottomRect.corners[(i + 1) % n1];

                for (let j = 0; j < n2; j++) {
                    const p3 = topRect.corners[j];
                    const p4 = topRect.corners[(j + 1) % n2];

                    const intersection = lineSegmentsIntersect(p1, p2, p3, p4);
                    if (intersection) {
                        intersections.push({
                            point: intersection,
                            bottomEdge: i,
                            topCornerAfter: (j + 1) % n2
                        });
                    }
                }
            }

            return intersections;
        }

        function resolveOverlap(bottomRect, topRect) {
            // Make the bottom box "wrap around" the top box like it's repelling it
            if (!polygonsOverlap(bottomRect, topRect)) return false;

            const n1 = bottomRect.corners.length;
            const n2 = topRect.corners.length;
            const newCorners = [];
            let addedTopCorners = false;

            // Find ALL intersection points first
            const allIntersections = [];
            for (let i = 0; i < n1; i++) {
                const p1 = bottomRect.corners[i];
                const p2 = bottomRect.corners[(i + 1) % n1];

                for (let j = 0; j < n2; j++) {
                    const p3 = topRect.corners[j];
                    const p4 = topRect.corners[(j + 1) % n2];

                    const intersection = lineSegmentsIntersect(p1, p2, p3, p4);
                    if (intersection) {
                        allIntersections.push({
                            point: intersection,
                            bottomEdge: i,
                            topEdge: j,
                            distOnBottomEdge: Math.sqrt(
                                (intersection.x - p1.x) ** 2 + (intersection.y - p1.y) ** 2
                            )
                        });
                    }
                }
            }

            // If no intersections, skip (island case - user can manually adjust)
            if (allIntersections.length === 0) {
                return false;
            }

            // Sort intersections by bottom edge, then by distance
            allIntersections.sort((a, b) => {
                if (a.bottomEdge !== b.bottomEdge) return a.bottomEdge - b.bottomEdge;
                return a.distOnBottomEdge - b.distOnBottomEdge;
            });

            // Walk around bottom rect, and when we hit the top rect, trace around it
            for (let i = 0; i < n1; i++) {
                const corner = bottomRect.corners[i];

                // Add corner only if it's NOT inside the top rect
                if (!polygonContainsPoint(topRect, corner)) {
                    newCorners.push({...corner});
                }

                // Get intersections on this edge
                const edgeIntersections = allIntersections.filter(int => int.bottomEdge === i);

                if (edgeIntersections.length > 0 && !addedTopCorners) {
                    // Add first intersection point
                    newCorners.push({...edgeIntersections[0].point});

                    // Add top corners that are INSIDE bottom rect
                    const startTopCorner = (edgeIntersections[0].topEdge + 1) % n2;
                    for (let j = 0; j < n2; j++) {
                        const topCornerIdx = (startTopCorner + j) % n2;
                        const topCorner = topRect.corners[topCornerIdx];

                        // Add this top corner if it's inside the bottom rect
                        if (polygonContainsPoint(bottomRect, topCorner)) {
                            newCorners.push({...topCorner});
                        }
                    }

                    // Add remaining intersections on this edge
                    for (let j = 1; j < edgeIntersections.length; j++) {
                        newCorners.push({...edgeIntersections[j].point});
                    }

                    addedTopCorners = true;
                } else if (edgeIntersections.length > 0) {
                    // Just add remaining intersection points
                    for (const inter of edgeIntersections) {
                        newCorners.push({...inter.point});
                    }
                }
            }

            // Update if we modified the shape
            if (newCorners.length > bottomRect.corners.length) {
                bottomRect.corners = newCorners;
                return true;
            }

            return false;
        }

        function resolveAllOverlaps() {
            // Process all rectangles to resolve overlaps
            // Later rectangles in the array are considered "on top"
            let resolved = false;

            for (let i = 0; i < rectangles.length - 1; i++) {
                for (let j = i + 1; j < rectangles.length; j++) {
                    // j is on top of i, so modify i to wrap around j
                    if (resolveOverlap(rectangles[i], rectangles[j])) {
                        resolved = true;
                    }
                }
            }

            return resolved;
        }

        function confirmRectPosition() {
            // Confirm the selected rectangle's position and make it wrap around other boxes
            if (!selectedRect) return;

            saveHistory();

            // Mark this rect as confirmed
            confirmedRects.add(selectedRect);

            // Apply overlap resolution: make all OTHER rectangles wrap around this confirmed one
            let resolved = false;
            for (let i = 0; i < rectangles.length; i++) {
                const rect = rectangles[i];
                if (rect === selectedRect) continue; // Skip the confirmed rect itself

                // Make other boxes wrap around the selected (confirmed) box
                if (resolveOverlap(rect, selectedRect)) {
                    resolved = true;
                }
            }

            if (resolved) {
                redraw();
                // Show feedback
                const toast = document.createElement('div');
                toast.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4caf50; color: white; padding: 12px 20px; border-radius: 8px; z-index: 10000; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
                toast.textContent = 'Position confirmed - overlapping boxes adjusted';
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2000);
            }
        }

        function autoConfirmFullyCoveredBoxes() {
            // Automatically apply overlap resolution to all overlapping boxes on detection
            // Process from bottom to top (later boxes in array are on top)
            let resolved = false;
            let resolutionCount = 0;

            // For each pair of overlapping rectangles, make the bottom one wrap around the top one
            for (let i = 0; i < rectangles.length; i++) {
                for (let j = i + 1; j < rectangles.length; j++) {
                    // Check if they overlap
                    if (polygonsOverlap(rectangles[i], rectangles[j])) {
                        // Make rectangle i (bottom) wrap around rectangle j (top)
                        if (resolveOverlap(rectangles[i], rectangles[j])) {
                            resolved = true;
                            resolutionCount++;
                        }
                    }
                }
            }

            if (resolved) {
                console.log(`[Auto-Detect] Applied overlap resolution to ${resolutionCount} box pair(s)`);
            }

            return resolved;
        }

        // Zoom with mouse wheel
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            const delta = e.deltaY;
            const zoomSpeed = 0.1;
            const oldZoom = zoomLevel;

            if (delta < 0) {
                // Zoom in
                zoomLevel = Math.min(zoomLevel + zoomSpeed, 5);  // Max 5x zoom
            } else {
                // Zoom out
                zoomLevel = Math.max(zoomLevel - zoomSpeed, 0.5);  // Min 0.5x zoom
            }

            if (oldZoom !== zoomLevel) {
                // When zooming back to 100%, reset pan offset
                if (zoomLevel === 1) {
                    panX = 0;
                    panY = 0;
                }

                updateCanvasSize();
                updateZoomIndicator();
                updateCanvasTransform();
                redraw();
            }
        }, { passive: false });

        // Keyboard shortcuts for zoom
        document.addEventListener('keydown', (e) => {
            // Only handle zoom keys when canvas is visible
            if (!canvasWrapper.classList.contains('active')) return;

            // Don't interfere with input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            const zoomSpeed = 0.1;
            let newZoom = zoomLevel;

            if (e.key === '+' || e.key === '=') {
                // Zoom in
                e.preventDefault();
                newZoom = Math.min(zoomLevel + zoomSpeed, 5);
            } else if (e.key === '-' || e.key === '_') {
                // Zoom out
                e.preventDefault();
                newZoom = Math.max(zoomLevel - zoomSpeed, 0.5);
            } else if (e.key === '0') {
                // Reset zoom
                e.preventDefault();
                newZoom = 1;
            }

            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;

                // When zooming back to 100%, reset pan offset
                if (zoomLevel === 1) {
                    panX = 0;
                    panY = 0;
                }

                updateCanvasSize();
                updateZoomIndicator();
                updateCanvasTransform();
                redraw();
            }
        });

        // Pan with Space key
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !spaceKeyDown && canvasWrapper.classList.contains('active')) {
                // Don't interfere with input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                e.preventDefault();
                spaceKeyDown = true;
                canvas.style.cursor = 'grab';
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spaceKeyDown = false;
                if (!isPanning) {
                    canvas.style.cursor = currentTool === 'rect' ? 'crosshair' : 'default';
                }
            }
        });

        // Pan on canvas-area (works everywhere, not just on canvas)
        canvasArea.addEventListener('mousedown', (e) => {
            if (e.button === 2) return;  // Right click

            // Check if clicking outside the canvas (in the canvas-area padding)
            const isOutsideCanvas = e.target !== canvas && !canvas.contains(e.target);

            // Auto-pan when clicking outside the canvas, or when using pan tool/space/middle click
            if (isOutsideCanvas || currentTool === 'pan' || (spaceKeyDown && e.button === 0) || e.button === 1) {
                e.preventDefault();
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                scrollStartX = panX;  // Store current pan offset
                scrollStartY = panY;
                canvasArea.classList.add('panning');
                canvas.style.cursor = 'grabbing';
                return;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) return;  // Right click
            if (isPanning) return;  // Already panning

            const pos = getMousePos(e);

            // Handle eraser tool explicitly
            if (currentTool === 'eraser' && !spaceKeyDown) {
                deleteRectangleAt(pos);
                return;
            }

            // Smart behavior: check if clicking on a panel
            const clickedRect = findRectangleAtPos(pos);

            if (clickedRect) {
                // Clicking on a panel - select it and enable editing
                if (currentTool !== 'rect') {
                    setActiveTool('rect');
                }
                selectedRect = clickedRect;
                handleRectMouseDown(pos);
                redraw();
            } else {
                // Clicking outside panels - start panning (unless already in rect tool drawing mode)
                if (currentTool === 'rect' && !spaceKeyDown) {
                    // Allow drawing new rectangles
                    handleRectMouseDown(pos);
                } else {
                    // Auto-pan when clicking outside panels
                    isPanning = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    scrollStartX = panX;
                    scrollStartY = panY;
                    canvasArea.classList.add('panning');
                    canvas.style.cursor = 'grabbing';
                }
            }
        });

        function findRectangleAtPos(pos) {
            // Check rectangles in reverse order (top to bottom)
            for (let i = rectangles.length - 1; i >= 0; i--) {
                if (isInsideRect(rectangles[i], pos)) {
                    return rectangles[i];
                }
            }
            return null;
        }

        function handleRectMouseDown(pos) {
            // PRIORITY: Check selected rectangle's corners first (solves overlap issue)
            if (selectedRect) {
                const cornerIdx = getCornerAtPos(selectedRect, pos);
                if (cornerIdx >= 0) {
                    saveHistory();
                    draggedCorner = cornerIdx;
                    cornerDragStartPos = { ...selectedRect.corners[cornerIdx] };
                    isDrawing = true;
                    canvas.style.cursor = 'grabbing';
                    redraw();
                    return;
                }
            }

            // Then check other rectangles for corner hits
            for (let i = rectangles.length - 1; i >= 0; i--) {
                const rect = rectangles[i];
                if (rect === selectedRect) continue; // Already checked
                const cornerIdx = getCornerAtPos(rect, pos);
                if (cornerIdx >= 0) {
                    saveHistory();
                    selectedRect = rect;
                    draggedCorner = cornerIdx;
                    cornerDragStartPos = { ...rect.corners[cornerIdx] };
                    isDrawing = true;
                    canvas.style.cursor = 'grabbing';
                    redraw();
                    return;
                }
            }

            // Check for clicks inside rectangles (selected rect has priority) - start dragging
            if (selectedRect && isInsideRect(selectedRect, pos)) {
                saveHistory();
                isDraggingRect = true;
                dragStartPos = { x: pos.x, y: pos.y };
                isDrawing = true;
                canvas.style.cursor = 'grabbing';
                return;
            }

            for (let i = rectangles.length - 1; i >= 0; i--) {
                const rect = rectangles[i];
                if (rect === selectedRect) continue;
                if (isInsideRect(rect, pos)) {
                    saveHistory();
                    selectedRect = rect;
                    isDraggingRect = true;
                    dragStartPos = { x: pos.x, y: pos.y };
                    isDrawing = true;
                    canvas.style.cursor = 'grabbing';
                    redraw();
                    return;
                }
            }

            // Start drawing new rectangle
            saveHistory();
            selectedRect = null;
            rectStartPos = pos;
            currentRect = {
                corners: [
                    { x: pos.x, y: pos.y },
                    { x: pos.x, y: pos.y },
                    { x: pos.x, y: pos.y },
                    { x: pos.x, y: pos.y }
                ]
            };
            isDrawing = true;
            redraw();
        }

        // Pan on document for smooth panning everywhere
        document.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - panStartX;
                const dy = e.clientY - panStartY;
                panX = scrollStartX + dx;
                panY = scrollStartY + dy;
                updateCanvasTransform();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            // Skip if panning
            if (isPanning) return;

            mousePos = getMousePos(e);

            if (currentTool === 'rect' && !spaceKeyDown) {
                handleRectMouseMove(mousePos, e.ctrlKey);
                updateRectCursor(mousePos);
            }
        });

        function updateRectCursor(pos) {
            // PRIORITY: Check selected rectangle first for corner hover
            if (selectedRect) {
                const cornerIdx = getCornerAtPos(selectedRect, pos);
                if (cornerIdx >= 0) {
                    hoveredCorner = cornerIdx;
                    canvas.style.cursor = 'grab';
                    redraw();
                    return;
                }
            }

            // Then check other rectangles
            for (let i = rectangles.length - 1; i >= 0; i--) {
                const rect = rectangles[i];
                if (rect === selectedRect) continue;
                const cornerIdx = getCornerAtPos(rect, pos);
                if (cornerIdx >= 0) {
                    canvas.style.cursor = 'grab';
                    if (hoveredCorner !== null) {
                        hoveredCorner = null;
                        redraw();
                    }
                    return;
                }
            }

            if (hoveredCorner !== null) {
                hoveredCorner = null;
                redraw();
            }

            // Check edges (selected rect first)
            if (selectedRect) {
                const edgeInfo = getEdgeAtPos(selectedRect, pos);
                if (edgeInfo.edge >= 0) {
                    canvas.style.cursor = 'cell';
                    return;
                }
            }
            for (let i = rectangles.length - 1; i >= 0; i--) {
                if (rectangles[i] === selectedRect) continue;
                const edgeInfo = getEdgeAtPos(rectangles[i], pos);
                if (edgeInfo.edge >= 0) {
                    canvas.style.cursor = 'cell';
                    return;
                }
            }

            // Check inside (selected rect first) - show move cursor
            if (selectedRect && isInsideRect(selectedRect, pos)) {
                canvas.style.cursor = 'move';
                return;
            }
            for (let i = rectangles.length - 1; i >= 0; i--) {
                if (rectangles[i] === selectedRect) continue;
                if (isInsideRect(rectangles[i], pos)) {
                    canvas.style.cursor = 'move';
                    return;
                }
            }

            canvas.style.cursor = 'crosshair';
        }

        function handleRectMouseMove(pos, ctrlKey = false) {
            if (!isDrawing) return;

            // Dragging a corner - clamp to image bounds independently for each axis
            if (draggedCorner !== null && selectedRect) {
                let targetX = pos.x;
                let targetY = pos.y;

                // Ctrl+drag constrains to horizontal or vertical movement
                if (ctrlKey && cornerDragStartPos) {
                    const dx = Math.abs(pos.x - cornerDragStartPos.x);
                    const dy = Math.abs(pos.y - cornerDragStartPos.y);
                    if (dx > dy) {
                        // Horizontal movement - lock Y
                        targetY = cornerDragStartPos.y;
                    } else {
                        // Vertical movement - lock X
                        targetX = cornerDragStartPos.x;
                    }
                }

                // Clamp each axis independently so you can still move along one edge
                const clampedX = Math.max(0, Math.min(currentImage.width, targetX));
                const clampedY = Math.max(0, Math.min(currentImage.height, targetY));
                selectedRect.corners[draggedCorner] = { x: clampedX, y: clampedY };
                redraw();
                return;
            }

            // Dragging entire rectangle
            if (isDraggingRect && selectedRect && dragStartPos) {
                const dx = pos.x - dragStartPos.x;
                const dy = pos.y - dragStartPos.y;

                // Calculate new positions and check bounds
                const newCorners = selectedRect.corners.map(c => ({
                    x: c.x + dx,
                    y: c.y + dy
                }));

                // Check if any corner would go out of bounds
                const minX = Math.min(...newCorners.map(c => c.x));
                const maxX = Math.max(...newCorners.map(c => c.x));
                const minY = Math.min(...newCorners.map(c => c.y));
                const maxY = Math.max(...newCorners.map(c => c.y));

                // Adjust delta if needed to keep rectangle in bounds
                let adjustedDx = dx;
                let adjustedDy = dy;

                if (minX < 0) adjustedDx = dx - minX;
                else if (maxX > currentImage.width) adjustedDx = dx - (maxX - currentImage.width);

                if (minY < 0) adjustedDy = dy - minY;
                else if (maxY > currentImage.height) adjustedDy = dy - (maxY - currentImage.height);

                // Apply movement
                selectedRect.corners.forEach(c => {
                    c.x += adjustedDx;
                    c.y += adjustedDy;
                });

                dragStartPos = { x: dragStartPos.x + adjustedDx, y: dragStartPos.y + adjustedDy };
                redraw();
                return;
            }

            if (currentRect && rectStartPos) {
                // Clamp to image bounds when drawing new rectangle
                const clampedX = Math.max(0, Math.min(currentImage.width, pos.x));
                const clampedY = Math.max(0, Math.min(currentImage.height, pos.y));
                currentRect.corners[0] = { x: rectStartPos.x, y: rectStartPos.y };
                currentRect.corners[1] = { x: clampedX, y: rectStartPos.y };
                currentRect.corners[2] = { x: clampedX, y: clampedY };
                currentRect.corners[3] = { x: rectStartPos.x, y: clampedY };
                redraw();
            }
        }

        canvas.addEventListener('mouseup', () => {
            // Stop panning
            if (isPanning) {
                isPanning = false;
                canvasArea.classList.remove('panning');
                if (currentTool === 'pan') {
                    canvas.style.cursor = 'grab';
                } else if (spaceKeyDown) {
                    canvas.style.cursor = 'grab';
                } else if (currentTool === 'rect') {
                    canvas.style.cursor = 'crosshair';
                }
                return;
            }

            if (currentTool === 'rect' && isDrawing) {
                handleRectMouseUp();
            }

            // Overlap resolution disabled during movement - use manual confirmation instead
            // if (isDraggingRect && rectangles.length > 1) {
            //     resolveAllOverlaps();
            // }

            isDrawing = false;
            draggedCorner = null;
            cornerDragStartPos = null;
            isDraggingRect = false;
            dragStartPos = null;
            if (currentTool === 'rect' && mousePos) {
                updateRectCursor(mousePos);
            }
        });

        function handleRectMouseUp() {
            if (currentRect && rectStartPos) {
                const minSize = 20;
                const width = Math.abs(currentRect.corners[2].x - currentRect.corners[0].x);
                const height = Math.abs(currentRect.corners[2].y - currentRect.corners[0].y);
                if (width > minSize && height > minSize) {
                    rectangles.push(currentRect);
                    selectedRect = currentRect;

                    // Overlap resolution disabled during drawing - use manual confirmation instead
                    // if (rectangles.length > 1) {
                    //     resolveAllOverlaps();
                    // }

                    updateExtractButton();
                    showEditTools();
                }
                currentRect = null;
                rectStartPos = null;
                redraw();
            }
        }

        document.addEventListener('mouseup', () => {
            // Stop panning
            if (isPanning) {
                isPanning = false;
                canvasArea.classList.remove('panning');
                if (currentTool === 'pan') {
                    canvas.style.cursor = 'grab';
                    canvasArea.style.cursor = 'grab';
                } else if (spaceKeyDown) {
                    canvas.style.cursor = 'grab';
                } else if (currentTool === 'rect') {
                    canvas.style.cursor = 'crosshair';
                    canvasArea.style.cursor = 'default';
                } else {
                    canvas.style.cursor = 'default';
                    canvasArea.style.cursor = 'default';
                }
            }

            if (draggedCorner !== null || isDraggingRect || currentRect) {
                // Finalize new rectangle if drawing
                if (currentRect && rectStartPos) {
                    const minSize = 20;
                    const width = Math.abs(currentRect.corners[2].x - currentRect.corners[0].x);
                    const height = Math.abs(currentRect.corners[2].y - currentRect.corners[0].y);
                    if (width > minSize && height > minSize) {
                        rectangles.push(currentRect);
                        selectedRect = currentRect;

                        // Overlap resolution disabled during drawing - use manual confirmation instead
                        // if (rectangles.length > 1) {
                        //     resolveAllOverlaps();
                        // }

                        updateExtractButton();
                        showEditTools();
                    }
                    currentRect = null;
                    rectStartPos = null;
                    redraw();
                }

                // Overlap resolution disabled during movement - use manual confirmation instead
                // if (isDraggingRect && rectangles.length > 1) {
                //     resolveAllOverlaps();
                // }

                isDrawing = false;
                draggedCorner = null;
                cornerDragStartPos = null;
                isDraggingRect = false;
                dragStartPos = null;
            }
        });

        // Track mouse movement even when outside canvas (for edge dragging and new rectangles)
        document.addEventListener('mousemove', (e) => {
            if (isDrawing && (draggedCorner !== null || isDraggingRect || currentRect)) {
                const rect = canvas.getBoundingClientRect();
                const totalScale = scale * zoomLevel;
                const pos = {
                    x: (e.clientX - rect.left) / totalScale,
                    y: (e.clientY - rect.top) / totalScale
                };
                handleRectMouseMove(pos, e.ctrlKey);
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            cancelCurrentAction();
        });

        canvas.addEventListener('dblclick', (e) => {
            if (currentTool === 'rect') {
                const pos = getMousePos(e);
                if (selectedRect) {
                    const edgeInfo = getEdgeAtPos(selectedRect, pos);
                    if (edgeInfo.edge >= 0) {
                        saveHistory();
                        addPointToEdge(selectedRect, edgeInfo.edge, pos);
                        redraw();
                        return;
                    }
                }
                for (let i = rectangles.length - 1; i >= 0; i--) {
                    const rect = rectangles[i];
                    const edgeInfo = getEdgeAtPos(rect, pos);
                    if (edgeInfo.edge >= 0) {
                        saveHistory();
                        selectedRect = rect;
                        addPointToEdge(rect, edgeInfo.edge, pos);
                        redraw();
                        return;
                    }
                }
            }
        });

        function cancelCurrentAction() {
            if (currentRect) {
                currentRect = null;
                rectStartPos = null;
                redraw();
            }
            if (selectedRect) {
                selectedRect = null;
                redraw();
            }
        }

        function deleteRectangleAt(pos) {
            for (let i = rectangles.length - 1; i >= 0; i--) {
                if (isInsideRect(rectangles[i], pos)) {
                    saveHistory();
                    rectangles.splice(i, 1);
                    selectedRect = null;
                    updateExtractButton();
                    redraw();
                    return;
                }
            }
        }

        // =====================================================================
        // HISTORY (UNDO/REDO)
        // =====================================================================
        function saveHistory() {
            redoHistory = [];
            const state = {
                rectangles: JSON.parse(JSON.stringify(rectangles))
            };
            history.push(state);
            if (history.length > 30) history.shift();
        }

        function undo() {
            if (history.length > 0) {
                const currentState = {
                    rectangles: JSON.parse(JSON.stringify(rectangles))
                };
                redoHistory.push(currentState);

                const state = history.pop();
                rectangles = state.rectangles || [];
                confirmedRects.clear(); // Clear confirmed status on undo
                selectedRect = null;
                currentRect = null;
                updateExtractButton();
                redraw();
            }
        }

        function redo() {
            if (redoHistory.length > 0) {
                const currentState = {
                    rectangles: JSON.parse(JSON.stringify(rectangles))
                };
                history.push(currentState);

                const state = redoHistory.pop();
                rectangles = state.rectangles || [];
                confirmedRects.clear(); // Clear confirmed status on redo
                selectedRect = null;
                currentRect = null;
                updateExtractButton();
                redraw();
            }
        }

        // =====================================================================
        // KEYBOARD SHORTCUTS
        // =====================================================================
        document.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT') return;

            if (e.key === 'Escape') {
                cancelCurrentAction();
            } else if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.key === 'h' || e.key === 'H') {
                setActiveTool('pan');
            } else if (e.key === 'r' || e.key === 'R') {
                if (!e.ctrlKey) setActiveTool('rect');
            } else if (e.key === 'd' || e.key === 'D') {
                setActiveTool('eraser');
            } else if (e.key === 'Enter' && selectedRect) {
                // Confirm selected rectangle and apply overlap resolution
                e.preventDefault();
                confirmRectPosition();
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedRect && currentTool === 'rect') {
                    if (hoveredCorner !== null && selectedRect.corners.length > 3) {
                        saveHistory();
                        selectedRect.corners.splice(hoveredCorner, 1);
                        hoveredCorner = null;
                        redraw();
                    } else {
                        saveHistory();
                        const idx = rectangles.indexOf(selectedRect);
                        if (idx >= 0) rectangles.splice(idx, 1);
                        selectedRect = null;
                        hoveredCorner = null;
                        updateExtractButton();
                        redraw();
                    }
                }
            } else if (e.key === 'ArrowLeft' && bulkMode) {
                // Previous page in bulk mode
                if (currentPageIndex > 0) loadPage(currentPageIndex - 1);
            } else if (e.key === 'ArrowRight' && bulkMode) {
                // Next page in bulk mode
                if (currentPageIndex < bulkPages.length - 1) loadPage(currentPageIndex + 1);
            }
        });

        // =====================================================================
        // TOOL BUTTONS
        // =====================================================================
        function setActiveTool(tool) {
            currentTool = tool;
            panBtn.classList.toggle('active', tool === 'pan');
            rectBtn.classList.toggle('active', tool === 'rect');
            eraserBtn.classList.toggle('active', tool === 'eraser');
            canvasWrapper.classList.toggle('eraser-mode', tool === 'eraser');

            // Update canvas cursor based on tool
            if (tool === 'pan') {
                canvas.style.cursor = 'grab';
                canvasArea.style.cursor = 'grab';
            } else if (tool === 'rect') {
                canvas.style.cursor = 'crosshair';
                canvasArea.style.cursor = 'default';
            } else {
                canvas.style.cursor = 'default';
                canvasArea.style.cursor = 'default';
            }

            if (tool !== 'rect') {
                currentRect = null;
                rectStartPos = null;
            }
            redraw();
        }

        panBtn.addEventListener('click', () => setActiveTool('pan'));
        rectBtn.addEventListener('click', () => setActiveTool('rect'));
        eraserBtn.addEventListener('click', () => setActiveTool('eraser'));
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);

        clearBtn.addEventListener('click', () => {
            saveHistory();
            rectangles = [];
            confirmedRects.clear(); // Clear confirmed status
            currentRect = null;
            selectedRect = null;
            updateExtractButton();
            redraw();
        });

        // =====================================================================
        // UI STATE MANAGEMENT
        // =====================================================================
        function updateExtractButton() {
            extractBtn.disabled = rectangles.length === 0;
        }

        function showEditTools() {
            editTools.classList.remove('hidden');
            editDivider.classList.remove('hidden');
        }

        function hideEditTools() {
            editTools.classList.add('hidden');
            editDivider.classList.add('hidden');
        }

        function showExportTools() {
            exportTools.classList.remove('hidden');
            sidebarActions.classList.remove('hidden');
        }

        function hideExportTools() {
            exportTools.classList.add('hidden');
            sidebarActions.classList.add('hidden');
        }

        function showNewPageBtn() {
            newPageBtn.disabled = false;
        }

        function hideNewPageBtn() {
            newPageBtn.disabled = true;
        }

        function clearPanelsList() {
            panelsList.innerHTML = '';
            panelCountBadge.textContent = '0';
            sidebarEmpty.style.display = 'flex';
        }

        function resetToStart() {
            // Reset all state
            currentImage = null;
            currentImageData = null;
            currentPanels = [];
            selectedPanels.clear();
            rectangles = [];
            lastExtractedRectangles = null;
            currentRect = null;
            selectedRect = null;
            draggedCorner = null;
            hoveredCorner = null;
            rectStartPos = null;
            dragStartPos = null;
            cornerDragStartPos = null;
            isDraggingRect = false;
            history = [];
            redoHistory = [];
            lastYoloResult = null;
            maskCanvas = null;
            maskCtx = null;

            // Reset bulk mode state
            bulkMode = false;
            bulkPages = [];
            currentPageIndex = 0;

            // Reset UI
            dropZone.classList.remove('hidden');
            canvasWrapper.classList.remove('active');
            autoDetectBtn.disabled = true;
            extractBtn.disabled = true;
            // headerInfo removed = 'Upload an image to start';

            hideEditTools();
            hideExportTools();
            hideNewPageBtn();
            hideBulkMode();
            clearPanelsList();
            sidebarEmpty.querySelector('p').innerHTML = 'Upload an image and click<br><strong>Auto-Detect</strong> to find panels';

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Reset file input so same file can be selected again
            fileInput.value = '';
        }

        function showDetectionToast(method, panelCount) {
            let bg, label;
            if (method === 'hybrid') {
                bg = 'linear-gradient(135deg, #9C27B0, #7B1FA2)';
                label = 'Hybrid Detection';
            } else if (method === 'segmentation') {
                bg = 'linear-gradient(135deg, #FF5722, #E64A19)';
                label = 'Seg v2 Detection';
            } else if (method === 'yolo') {
                bg = 'linear-gradient(135deg, #4CAF50, #45a049)';
                label = 'YOLO Detection';
            } else {
                bg = 'linear-gradient(135deg, #2196F3, #1976D2)';
                label = 'CV Detection';
            }

            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 60px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: bold;
                z-index: 10000;
                animation: slideIn 0.3s ease, fadeOut 0.3s ease 2.7s;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                background: ${bg};
            `;
            toast.innerHTML = `
                <div style="font-size: 14px;">${label}</div>
                <div style="font-size: 12px; opacity: 0.9; margin-top: 4px;">Found ${panelCount} panel${panelCount !== 1 ? 's' : ''}</div>
            `;

            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function updateLoadingText(text) {
            const loadingContent = loading.querySelector('.loading-content p');
            if (loadingContent) {
                loadingContent.textContent = text;
            }
        }

        // =====================================================================
        // BULK MODE FUNCTIONS
        // =====================================================================
        function showBulkMode() {
            dropZone.classList.add('hidden');
            canvasWrapper.classList.add('active');

            // Show bulk-specific UI
            pageNavigator.style.display = 'flex';
            pageThumbsStrip.style.display = 'flex';
            bulkActions.classList.remove('hidden');

            // Hide single-page actions, show bulk actions
            autoDetectBtn.style.display = 'none';
            extractBtn.style.display = 'none';

            showNewPageBtn();
            // headerInfo removed = `${bulkPages.length} pages loaded`;

            // Build page thumbnails
            updatePageThumbnails();
        }

        function hideBulkMode() {
            pageNavigator.style.display = 'none';
            pageThumbsStrip.style.display = 'none';
            bulkActions.classList.add('hidden');

            autoDetectBtn.style.display = '';
            extractBtn.style.display = '';
        }

        function saveCurrentPageState() {
            if (!bulkMode || bulkPages.length === 0) return;
            bulkPages[currentPageIndex].rectangles = JSON.parse(JSON.stringify(rectangles));
        }

        function loadPage(index, skipSave = false) {
            if (!bulkMode || bulkPages.length === 0) return;
            if (index < 0 || index >= bulkPages.length) return;

            if (!skipSave) {
                saveCurrentPageState();  // Save current before switching
            }

            currentPageIndex = index;
            const page = bulkPages[index];

            currentImage = page.image;
            currentImageData = page.imageData;
            rectangles = page.rectangles ? JSON.parse(JSON.stringify(page.rectangles)) : [];
            currentPanels = page.panels || [];
            selectedPanels.clear();
            currentPanels.forEach(p => selectedPanels.add(p.index));

            // Reset edit state
            selectedRect = null;
            currentRect = null;
            history = [];
            redoHistory = [];

            initCanvas();
            redraw();
            updatePageNavigator();
            updatePageThumbnails();
            updateExtractButton();

            // Update sidebar based on extraction state
            if (page.extracted && page.panels.length > 0) {
                displayPanels({ panels: page.panels, panel_count: page.panels.length });
            } else {
                clearPanelsList();
                if (page.detected) {
                    sidebarEmpty.querySelector('p').innerHTML = 'Edit panels on canvas, then<br>click <strong>Extract All</strong>';
                } else {
                    sidebarEmpty.querySelector('p').innerHTML = 'Click <strong>Detect All</strong><br>to find panels on all pages';
                }
            }

            // Show edit tools if there are rectangles
            if (rectangles.length > 0) {
                showEditTools();
            }

            // headerInfo removed = `Page ${index + 1} of ${bulkPages.length} - ${page.fileName}`;
        }

        function updatePageNavigator() {
            pageIndicator.textContent = `Page ${currentPageIndex + 1} / ${bulkPages.length}`;
            prevPageBtn.disabled = currentPageIndex <= 0;
            nextPageBtn.disabled = currentPageIndex >= bulkPages.length - 1;
        }

        function removePage(pageIndex) {
            if (bulkPages.length <= 1) {
                alert('Cannot remove the last page. You need at least one page.');
                return;
            }

            // Confirm deletion
            if (!confirm(`Remove page ${pageIndex + 1}?`)) {
                return;
            }

            // Remove the page
            bulkPages.splice(pageIndex, 1);

            // Adjust current page index if needed
            if (currentPageIndex >= bulkPages.length) {
                // If we removed the last page, go to the new last page
                currentPageIndex = bulkPages.length - 1;
            } else if (currentPageIndex > pageIndex) {
                // If we removed a page before the current one, adjust the index
                currentPageIndex--;
            }
            // If currentPageIndex === pageIndex, we removed the current page,
            // so we'll reload the same index (which now has a different page)

            // Update UI
            updatePageThumbnails();
            loadPage(currentPageIndex);
            updateExtractAllButton();
        }

        function updatePageThumbnails() {
            pageThumbsStrip.innerHTML = '';

            bulkPages.forEach((page, idx) => {
                const thumb = document.createElement('div');
                thumb.className = 'page-thumb';
                if (idx === currentPageIndex) thumb.classList.add('active');
                if (page.detected) thumb.classList.add('detected');
                if (page.extracted) thumb.classList.add('extracted');

                thumb.innerHTML = `
                    <img src="${page.imageData}" alt="Page ${idx + 1}">
                    <button class="page-thumb-delete" title="Remove page">Ã—</button>
                    <span class="page-thumb-number">${idx + 1}</span>
                    <span class="page-thumb-status"></span>
                `;

                // Click thumbnail to switch pages
                thumb.addEventListener('click', (e) => {
                    // Don't switch pages if clicking the delete button
                    if (!e.target.classList.contains('page-thumb-delete')) {
                        if (idx !== currentPageIndex) {
                            loadPage(idx);
                        }
                    }
                });

                // Delete button handler
                const deleteBtn = thumb.querySelector('.page-thumb-delete');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removePage(idx);
                });

                pageThumbsStrip.appendChild(thumb);
            });

            // Scroll active thumbnail into view
            const activeThumb = pageThumbsStrip.querySelector('.page-thumb.active');
            if (activeThumb) {
                activeThumb.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }
        }

        function updateExtractAllButton() {
            // Enable Extract All if at least one page has rectangles
            const hasRectangles = bulkPages.some(p => p.rectangles && p.rectangles.length > 0);
            extractAllBtn.disabled = !hasRectangles;
        }

        function panelsToRectangles(panelsData, useObbCorners = false) {
            return panelsData.map(panel => {
                if (useObbCorners && panel.corners && panel.corners.length === 4) {
                    return { corners: panel.corners.map(c => ({ x: c.x, y: c.y })) };
                } else if (panel.bounding_box) {
                    const bbox = panel.bounding_box;
                    return {
                        corners: [
                            { x: bbox.x, y: bbox.y },
                            { x: bbox.x + bbox.width, y: bbox.y },
                            { x: bbox.x + bbox.width, y: bbox.y + bbox.height },
                            { x: bbox.x, y: bbox.y + bbox.height }
                        ]
                    };
                }
                return null;
            }).filter(r => r !== null);
        }

        // Build mask from rectangles (used for extraction)
        async function buildMaskFromRectangles(image, rects) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = image.width;
            tempCanvas.height = image.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Black background (non-panel areas)
            tempCtx.fillStyle = '#000000';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // White for panel areas
            rects.forEach(rect => {
                if (!rect.corners || rect.corners.length < 3) return;
                tempCtx.fillStyle = '#ffffff';
                tempCtx.beginPath();
                tempCtx.moveTo(rect.corners[0].x, rect.corners[0].y);
                for (let i = 1; i < rect.corners.length; i++) {
                    tempCtx.lineTo(rect.corners[i].x, rect.corners[i].y);
                }
                tempCtx.closePath();
                tempCtx.fill();

                // Draw border
                tempCtx.strokeStyle = '#000000';
                tempCtx.lineWidth = 3;
                tempCtx.stroke();
            });

            return new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
        }

        // =====================================================================
        // BULK DETECT ALL
        // =====================================================================
        async function detectAllPages() {
            if (!bulkMode || bulkPages.length === 0) return;

            loading.classList.add('active');
            const rtl = rtlToggle.checked;
            const model = modelSelect.value;

            try {
                for (let i = 0; i < bulkPages.length; i++) {
                    updateLoadingText(`Detecting page ${i + 1} of ${bulkPages.length}...`);

                    const page = bulkPages[i];
                    // Always re-detect to allow switching models
                    // Clear previous rectangles for this page
                    page.rectangles = [];
                    page.detected = false;

                    const formData = new FormData();
                    const blob = await fetch(page.imageData).then(r => r.blob());
                    formData.append('image', blob);

                    // Determine endpoint and model based on selection
                    let endpoint;
                    if (model === 'seg_v2') {
                        endpoint = `/api/slice_seg?min_area=10000&rtl=${rtl}&seg_model=models/manga_panels_seg_v2.pt`;
                    } else if (model === 'hybrid') {
                        endpoint = `/api/slice_hybrid_models?min_area=10000&rtl=${rtl}&yolo_model=models/manga109_yolo.pt&seg_model=models/manga_panels_seg_v2.pt`;
                    } else {
                        // YOLO (Manga109) - detect panels (class 2)
                        endpoint = `/api/slice_hybrid?min_area=10000&rtl=${rtl}&tolerance=30&debug=false&yolo_model=models/manga109_yolo.pt&prefer_yolo=true&refine_corners=false`;
                    }

                    const response = await fetch(endpoint, { method: 'POST', body: formData });

                    // Check for rate limiting
                    if (response.status === 429) {
                        throw new Error('Too many requests. Please wait a moment and try again. (If testing locally, this shouldn\'t happen - check server logs)');
                    }

                    // Check for other errors
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Detection failed: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();

                    if (data.panels && data.panels.length > 0) {
                        page.rectangles = panelsToRectangles(data.panels, model === 'seg_v2' || model === 'hybrid');
                        page.detected = true;
                    }

                    // Update thumbnail to show detected status
                    updatePageThumbnails();
                }

                loadPage(currentPageIndex, true);  // Refresh current page, skip save to preserve detection results
                showEditTools();
                updateExtractAllButton();
            } catch (error) {
                console.error('Bulk detect error:', error);
                alert('Error during bulk detection: ' + error.message);
            } finally {
                loading.classList.remove('active');
                updateLoadingText('Processing...');
            }
        }

        // =====================================================================
        // BULK EXTRACT ALL
        // =====================================================================
        async function extractAllPages() {
            if (!bulkMode || bulkPages.length === 0) return;

            // Save current page state first
            saveCurrentPageState();

            loading.classList.add('active');
            const rtl = rtlToggle.checked;

            try {
                for (let i = 0; i < bulkPages.length; i++) {
                    updateLoadingText(`Extracting page ${i + 1} of ${bulkPages.length}...`);

                    const page = bulkPages[i];
                    if (!page.rectangles || page.rectangles.length === 0) continue;

                    // Build mask from rectangles
                    const maskBlob = await buildMaskFromRectangles(page.image, page.rectangles);

                    const formData = new FormData();
                    const imageBlob = await fetch(page.imageData).then(r => r.blob());
                    formData.append('image', imageBlob);
                    formData.append('mask', maskBlob);

                    const response = await fetch(`/api/slice_with_mask?min_area=10000&rtl=${rtl}`, {
                        method: 'POST', body: formData
                    });
                    const data = await response.json();

                    page.panels = data.panels || [];
                    page.extracted = true;

                    // Update thumbnail
                    updatePageThumbnails();
                }

                // Reload current page to show extracted panels
                loadPage(currentPageIndex, true);  // Skip save since we already saved at the start
                showExportTools();

                // Show total panel count
                const totalPanels = bulkPages.reduce((sum, p) => sum + (p.panels ? p.panels.length : 0), 0);
                bulkProgress.textContent = `${totalPanels} panels extracted`;
            } catch (error) {
                console.error('Bulk extract error:', error);
                alert('Error during bulk extraction: ' + error.message);
            } finally {
                loading.classList.remove('active');
                updateLoadingText('Processing...');
            }
        }

        // Page navigation button handlers
        prevPageBtn.addEventListener('click', () => {
            if (currentPageIndex > 0) loadPage(currentPageIndex - 1);
        });

        nextPageBtn.addEventListener('click', () => {
            if (currentPageIndex < bulkPages.length - 1) loadPage(currentPageIndex + 1);
        });

        detectAllBtn.addEventListener('click', detectAllPages);
        extractAllBtn.addEventListener('click', extractAllPages);

        // =====================================================================
        // AUTO-DETECT
        // =====================================================================
        autoDetectBtn.addEventListener('click', async () => {
            if (!currentImage) return;

            // Clear previous detection results before running new detection
            rectangles = [];
            redraw();

            loading.classList.add('active');

            try {
                const formData = new FormData();
                const blob = await fetch(currentImageData).then(r => r.blob());
                formData.append('image', blob);

                const minArea = 10000;
                const rtl = rtlToggle.checked;
                const selectedModel = modelSelect.value;

                let response;
                let usingFallback = false;

                if (selectedModel === 'seg_v2' || selectedModel === 'hybrid') {
                    let endpoint;

                    if (selectedModel === 'seg_v2') {
                        endpoint = `/api/slice_seg?min_area=${minArea}&rtl=${rtl}&seg_model=models/manga_panels_seg_v2.pt`;
                    } else {
                        // Hybrid - uses both YOLO and Seg models
                        endpoint = `/api/slice_hybrid_models?min_area=${minArea}&rtl=${rtl}&yolo_model=models/manga109_yolo.pt&seg_model=models/manga_panels_seg_v2.pt`;
                    }

                    response = await fetch(endpoint, {
                        method: 'POST',
                        body: formData
                    });

                    // Check if Seg v2 model doesn't exist yet
                    const checkData = await response.json();
                    if (checkData.error && checkData.model_exists === false && selectedModel === 'seg_v2') {
                        // Fall back to YOLO for detection
                        console.log('Seg v2 model not found, falling back to YOLO');
                        usingFallback = true;

                        // Re-fetch blob since we consumed it
                        const blob = await fetch(currentImageData).then(r => r.blob());
                        const fallbackFormData = new FormData();
                        fallbackFormData.append('image', blob);

                        response = await fetch(`/api/slice_hybrid?min_area=${minArea}&rtl=${rtl}&tolerance=30&debug=false&yolo_model=models/manga109_yolo.pt&prefer_yolo=true`, {
                            method: 'POST',
                            body: fallbackFormData
                        });
                    } else if (checkData.error) {
                        throw new Error(checkData.error);
                    } else {
                        // Model worked, continue with that data
                        if (checkData.panels && checkData.panels.length > 0) {
                            saveHistory();
                            lastYoloResult = checkData;
                            loadPanelsAsRectangles(checkData.panels, true);
                            showDetectionToast(checkData.detection_method, checkData.panel_count);
                            showEditTools();
                            return;
                        }
                    }
                } else {
                    // YOLO - detect panels (class 2)
                    response = await fetch(`/api/slice_hybrid?min_area=${minArea}&rtl=${rtl}&tolerance=30&debug=false&yolo_model=models/manga109_yolo.pt&prefer_yolo=true&refine_corners=false`, {
                        method: 'POST',
                        body: formData
                    });
                }

                // Check for rate limiting
                if (response.status === 429) {
                    throw new Error('Too many requests. Please wait a moment and try again.\n\n(If testing locally, this shouldn\'t happen - the rate limiter should be disabled. Check server console for "[Rate Limiter] Disabled" message)');
                }

                // Check for other errors before parsing JSON
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Detection error response:', errorText);
                    throw new Error(`Detection failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                if (data.error) throw new Error(data.error);

                // Show special message if we fell back to YOLO for Seg v2
                if (usingFallback) {
                    showDetectionToast('YOLO (Seg v2 not trained yet)', data.panel_count);
                    // Show additional info notification
                    setTimeout(() => {
                        alert('Seg v2 model not trained yet!\n\nUsing YOLO for now. Edit the detected panels to create quadrilaterals, then download to collect training data.\n\nOnce you have enough training data, run: train_seg_v2_model.bat\n\nAfter training, Seg v2 will automatically be used for detection.');
                    }, 500);
                }

                console.log('Detection method:', data.detection_method);
                console.log('Panel count:', data.panel_count);

                saveHistory();
                lastYoloResult = data;

                // Load panels as editable rectangles
                if (data.panels && data.panels.length > 0) {
                    loadPanelsAsRectangles(data.panels, selectedModel === 'obb' || selectedModel === 'seg_v2');
                }

                showDetectionToast(data.detection_method, data.panel_count);
                showEditTools();

            } catch (error) {
                console.error('Auto-detect error:', error);
                alert('Auto-detect error: ' + error.message);
            } finally {
                loading.classList.remove('active');
            }
        });

        function loadPanelsAsRectangles(panelsData, useObbCorners = false) {
            rectangles = [];
            selectedRect = null;

            console.log('[Refinement] Loading panels, count:', panelsData.length);

            panelsData.forEach((panel, i) => {
                let rect = null;

                // Use corners if they exist (from OBB, seg_v2, or refined YOLO detections)
                if (panel.corners && panel.corners.length === 4) {
                    console.log(`[Refinement] Panel ${i} has refined corners:`, panel.corners);
                    rect = {
                        corners: panel.corners.map(c => ({ x: c.x, y: c.y }))
                    };
                } else if (panel.bounding_box) {
                    // Fallback to bounding box if no corners
                    console.log(`[Refinement] Panel ${i} using bbox (no corners available)`);
                    const bbox = panel.bounding_box;
                    rect = {
                        corners: [
                            { x: bbox.x, y: bbox.y },
                            { x: bbox.x + bbox.width, y: bbox.y },
                            { x: bbox.x + bbox.width, y: bbox.y + bbox.height },
                            { x: bbox.x, y: bbox.y + bbox.height }
                        ]
                    };
                }

                if (rect) rectangles.push(rect);
            });

            // Auto-confirm boxes that are fully covered/inside other boxes
            if (rectangles.length > 1) {
                autoConfirmFullyCoveredBoxes();
            }

            setActiveTool('rect');
            updateExtractButton();
            // Update sidebar empty text
            sidebarEmpty.querySelector('p').innerHTML = 'Edit panels on canvas, then<br>click <strong>Extract Panels</strong>';
            redraw();
        }

        // =====================================================================
        // EXTRACT PANELS
        // =====================================================================
        extractBtn.addEventListener('click', async () => {
            if (!currentImage || rectangles.length === 0) return;

            loading.classList.add('active');

            try {
                lastExtractedRectangles = JSON.parse(JSON.stringify(rectangles));

                // Build mask from rectangles
                maskCtx.fillStyle = '#000000';
                maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);

                rectangles.forEach((rect) => {
                    if (!rect.corners || rect.corners.length < 3) return;

                    maskCtx.fillStyle = '#ffffff';
                    maskCtx.beginPath();
                    maskCtx.moveTo(rect.corners[0].x, rect.corners[0].y);
                    for (let i = 1; i < rect.corners.length; i++) {
                        maskCtx.lineTo(rect.corners[i].x, rect.corners[i].y);
                    }
                    maskCtx.closePath();
                    maskCtx.fill();

                    // Draw border
                    maskCtx.strokeStyle = '#000000';
                    maskCtx.lineWidth = 3;
                    maskCtx.stroke();
                });

                const maskBlob = await new Promise(resolve => maskCanvas.toBlob(resolve, 'image/png'));
                const formData = new FormData();
                const imageBlob = await fetch(currentImageData).then(r => r.blob());
                formData.append('image', imageBlob);
                formData.append('mask', maskBlob);

                const response = await fetch(`/api/slice_with_mask?min_area=10000&rtl=${rtlToggle.checked}`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (data.error) throw new Error(data.error);

                displayPanels(data);

            } catch (error) {
                alert('Extract error: ' + error.message);
            } finally {
                loading.classList.remove('active');
            }
        });

        // =====================================================================
        // DISPLAY PANELS IN SIDEBAR
        // =====================================================================
        let draggedPanel = null;

        function displayPanels(data) {
            currentPanels = data.panels;
            panelCountBadge.textContent = data.panel_count;

            // Select all by default
            selectedPanels.clear();
            data.panels.forEach(panel => selectedPanels.add(panel.index));

            // Clear and populate sidebar
            panelsList.innerHTML = '';
            sidebarEmpty.style.display = 'none';

            // Apply current view mode
            if (currentViewMode === 'grid') {
                panelsList.classList.add('grid-view');
            } else {
                panelsList.classList.remove('grid-view');
            }

            // Add reorder hint if multiple panels
            if (data.panels.length > 1) {
                const hint = document.createElement('div');
                hint.className = 'reorder-hint';
                hint.textContent = 'Drag to reorder panels';
                panelsList.appendChild(hint);
            }

            data.panels.forEach((panel, displayIndex) => {
                const thumb = document.createElement('div');
                thumb.className = 'panel-thumb selected';
                thumb.dataset.index = panel.index;
                thumb.dataset.displayIndex = displayIndex;
                thumb.draggable = true;

                thumb.innerHTML = `
                    <span class="drag-handle" title="Drag to reorder">&#8942;</span>
                    <span class="panel-thumb-number">${displayIndex + 1}</span>
                    <input type="checkbox" class="panel-thumb-checkbox" data-index="${panel.index}" checked>
                    <img src="data:image/png;base64,${panel.image}" alt="Panel ${displayIndex + 1}">
                `;

                const checkbox = thumb.querySelector('.panel-thumb-checkbox');
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    const idx = parseInt(e.target.dataset.index);
                    if (e.target.checked) {
                        selectedPanels.add(idx);
                        thumb.classList.add('selected');
                        thumb.classList.remove('unselected');
                    } else {
                        selectedPanels.delete(idx);
                        thumb.classList.remove('selected');
                        thumb.classList.add('unselected');
                    }
                    updateSelectionCount();
                });

                thumb.addEventListener('click', (e) => {
                    if (e.target.type !== 'checkbox' && !e.target.classList.contains('drag-handle')) {
                        highlightPanelOnCanvas(panel.index);
                    }
                });

                // Drag and drop events
                thumb.addEventListener('dragstart', (e) => {
                    draggedPanel = thumb;
                    thumb.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', displayIndex);
                });

                thumb.addEventListener('dragend', () => {
                    thumb.classList.remove('dragging');
                    draggedPanel = null;
                    document.querySelectorAll('.panel-thumb.drag-over').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                });

                thumb.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    if (draggedPanel && draggedPanel !== thumb) {
                        thumb.classList.add('drag-over');
                    }
                });

                thumb.addEventListener('dragleave', () => {
                    thumb.classList.remove('drag-over');
                });

                thumb.addEventListener('drop', (e) => {
                    e.preventDefault();
                    thumb.classList.remove('drag-over');

                    if (!draggedPanel || draggedPanel === thumb) return;

                    const fromIndex = parseInt(draggedPanel.dataset.displayIndex);
                    const toIndex = parseInt(thumb.dataset.displayIndex);

                    if (fromIndex !== toIndex) {
                        reorderPanels(fromIndex, toIndex);
                    }
                });

                panelsList.appendChild(thumb);
            });

            updateSelectionCount();
            showExportTools();
        }

        function reorderPanels(fromIndex, toIndex) {
            // Reorder currentPanels array
            const [movedPanel] = currentPanels.splice(fromIndex, 1);
            currentPanels.splice(toIndex, 0, movedPanel);

            // Also reorder rectangles to match (so canvas numbers update)
            if (rectangles.length === currentPanels.length + (toIndex > fromIndex ? 1 : 0) ||
                rectangles.length >= Math.max(fromIndex, toIndex) + 1) {
                // Only reorder if rectangles array exists and has matching length
                if (rectangles.length > 0) {
                    const [movedRect] = rectangles.splice(fromIndex, 1);
                    rectangles.splice(toIndex, 0, movedRect);
                }
            }

            // Update indices to match new order
            currentPanels.forEach((panel, idx) => {
                panel.index = idx;
            });

            // Update selectedPanels set with new indices
            const wasSelected = selectedPanels.has(fromIndex);
            selectedPanels.clear();
            currentPanels.forEach((panel, idx) => {
                // Re-select all (simplest approach)
                selectedPanels.add(idx);
            });

            // If in bulk mode, update the page's panels and rectangles arrays too
            if (bulkMode && bulkPages[currentPageIndex]) {
                bulkPages[currentPageIndex].panels = currentPanels;
                bulkPages[currentPageIndex].rectangles = JSON.parse(JSON.stringify(rectangles));
            }

            // Re-render the panel list and redraw canvas with updated numbers
            displayPanels({ panels: currentPanels, panel_count: currentPanels.length });
            redraw();
        }

        function highlightPanelOnCanvas(index) {
            if (index < rectangles.length) {
                selectedRect = rectangles[index];
                redraw();
            }
        }

        function updateSelectionCount() {
            const total = currentPanels.length;
            const selected = selectedPanels.size;
            panelCountBadge.textContent = `${selected}/${total}`;
            downloadBtn.disabled = selected === 0;
            downloadPsdBtn.disabled = selected === 0;
        }

        selectAllBtn.addEventListener('click', () => {
            selectedPanels.clear();
            currentPanels.forEach(panel => selectedPanels.add(panel.index));
            document.querySelectorAll('.panel-thumb-checkbox').forEach(cb => {
                cb.checked = true;
                cb.closest('.panel-thumb').classList.add('selected');
                cb.closest('.panel-thumb').classList.remove('unselected');
            });
            updateSelectionCount();
        });

        deselectAllBtn.addEventListener('click', () => {
            selectedPanels.clear();
            document.querySelectorAll('.panel-thumb-checkbox').forEach(cb => {
                cb.checked = false;
                cb.closest('.panel-thumb').classList.remove('selected');
                cb.closest('.panel-thumb').classList.add('unselected');
            });
            updateSelectionCount();
        });

        // View toggle buttons
        listViewBtn.addEventListener('click', () => {
            if (currentViewMode === 'list') return;
            currentViewMode = 'list';
            listViewBtn.classList.add('active');
            gridViewBtn.classList.remove('active');
            panelsList.classList.remove('grid-view');
        });

        gridViewBtn.addEventListener('click', () => {
            if (currentViewMode === 'grid') return;
            currentViewMode = 'grid';
            gridViewBtn.classList.add('active');
            listViewBtn.classList.remove('active');
            panelsList.classList.add('grid-view');
        });

        // New Page button - reset everything
        newPageBtn.addEventListener('click', () => {
            resetToStart();
        });

        // =====================================================================
        // DOWNLOAD
        // =====================================================================
        downloadBtn.addEventListener('click', async () => {
            try {
                downloadBtn.disabled = true;
                downloadBtn.textContent = 'Preparing...';

                let response;
                let downloadName;

                if (bulkMode && bulkPages.length > 0) {
                    // Bulk mode - download all pages
                    saveCurrentPageState();  // Save current page edits

                    const pagePanels = bulkPages.map(p => p.panels || []);
                    const totalPanels = pagePanels.reduce((sum, p) => sum + p.length, 0);

                    if (totalPanels === 0) {
                        alert('No panels to download. Run "Extract All" first.');
                        return;
                    }

                    // Call bulk download API
                    try {
                        response = await fetch('/api/download_bulk', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ pages: pagePanels })
                        });

                        // Check if response is ok
                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('Bulk download error response:', errorText);
                            throw new Error(`Bulk download failed: ${response.status} ${response.statusText}`);
                        }
                    } catch (e) {
                        console.error('Bulk download fetch error:', e);
                        throw new Error(`Bulk download error: ${e.message}`);
                    }

                    downloadName = 'manga_panels_bulk.zip';

                    // Auto-save training data for all pages
                    console.log(`Saving training data for ${bulkPages.length} pages...`);
                    for (let i = 0; i < bulkPages.length; i++) {
                        const page = bulkPages[i];
                        if (page.rectangles && page.rectangles.length > 0) {
                            try {
                                const boxes = page.rectangles.map((rect, idx) => {
                                    const corners = rect.corners;
                                    const xs = corners.map(c => c.x);
                                    const ys = corners.map(c => c.y);
                                    return {
                                        x: Math.min(...xs),
                                        y: Math.min(...ys),
                                        width: Math.max(...xs) - Math.min(...xs),
                                        height: Math.max(...ys) - Math.min(...ys),
                                        index: idx,
                                        corners: corners.map(c => ({ x: c.x, y: c.y }))
                                    };
                                });

                                const formData = new FormData();
                                const imageBlob = await fetch(page.imageData).then(r => r.blob());
                                formData.append('image', imageBlob);
                                formData.append('boxes', JSON.stringify(boxes));
                                // Always save downloaded training data to seg_v2
                                // Downloads include user-edited corners which train segmentation model
                                const modelVersion = 'seg_v2';
                                formData.append('model_version', modelVersion);

                                const saveResponse = await fetch('/api/save_training_sample', {
                                    method: 'POST',
                                    body: formData
                                });

                                if (!saveResponse.ok) {
                                    console.warn(`Training data save failed for page ${i + 1}: ${saveResponse.status}`);
                                }
                            } catch (e) {
                                console.warn(`Auto-save failed for page ${i + 1}:`, e);
                            }
                        }
                    }
                    console.log('Training data save complete');
                } else {
                    // Single page mode
                    if (selectedPanels.size === 0) {
                        alert('No panels selected.');
                        return;
                    }

                    const panelsToDownload = currentPanels.filter(p => selectedPanels.has(p.index));

                    // Build request body with training data included
                    const requestBody = { panels: panelsToDownload };

                    // Include original image and boxes for silent training data collection
                    if (currentImageData && lastExtractedRectangles && lastExtractedRectangles.length > 0) {
                        const boxes = lastExtractedRectangles.map((rect, idx) => {
                            const corners = rect.corners;
                            const xs = corners.map(c => c.x);
                            const ys = corners.map(c => c.y);
                            return {
                                x: Math.min(...xs),
                                y: Math.min(...ys),
                                width: Math.max(...xs) - Math.min(...xs),
                                height: Math.max(...ys) - Math.min(...ys),
                                index: idx,
                                corners: corners.map(c => ({ x: c.x, y: c.y }))
                            };
                        });
                        requestBody.original_image = currentImageData;
                        requestBody.boxes = boxes;
                        // Always save downloaded training data to seg_v2
                        // Downloads include user-edited corners which train segmentation model
                        const modelVersion = 'seg_v2';
                        requestBody.model_version = modelVersion;
                    }

                    response = await fetch('/api/download', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });
                    downloadName = 'manga_panels.zip';
                }

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Download error response:', errorText);
                    throw new Error(`Download failed: ${response.status} ${response.statusText}`);
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = downloadName;
                a.click();
                window.URL.revokeObjectURL(url);

                downloadBtn.textContent = 'Saved!';
                setTimeout(() => { downloadBtn.textContent = 'Download ZIP'; }, 1500);

                // Refresh stats after download
                fetchStats();

            } catch (error) {
                alert('Download error: ' + error.message);
            } finally {
                downloadBtn.disabled = false;
                if (downloadBtn.textContent === 'Preparing...') {
                    downloadBtn.textContent = 'Download ZIP';
                }
            }
        });

        downloadPsdBtn.addEventListener('click', async () => {
            if (selectedPanels.size === 0) return;

            try {
                downloadPsdBtn.disabled = true;
                downloadPsdBtn.textContent = 'Preparing...';

                const panelsToDownload = currentPanels.filter(p => selectedPanels.has(p.index));

                const response = await fetch('/api/export/psd', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ panels: panelsToDownload, layout: 'stacked' })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'PSD export failed');
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'manga_panels.psd';
                a.click();
                window.URL.revokeObjectURL(url);

            } catch (error) {
                alert('PSD Export error: ' + error.message);
            } finally {
                downloadPsdBtn.disabled = false;
                downloadPsdBtn.textContent = 'Download PSD';
            }
        });

        // =====================================================================
        // INIT
        // =====================================================================
        fetch('/api/capabilities')
            .then(r => r.json())
            .then(caps => {
                console.log('Server capabilities:', caps);
                if (!caps.psd_export) {
                    downloadPsdBtn.style.display = 'none';
                }
            })
            .catch(err => console.log('Could not fetch capabilities:', err));

        // Handle window resize
        window.addEventListener('resize', () => {
            if (currentImage) {
                initCanvas();
                redraw();
            }
        });
    </script>
</body>
</html>
